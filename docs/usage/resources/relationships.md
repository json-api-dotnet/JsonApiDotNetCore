# Relationships

A relationship is a named link between two resource types, including a direction.
They are similar to [navigation properties in Entity Framework Core](https://docs.microsoft.com/en-us/ef/core/modeling/relationships).

Relationships come in three flavors: to-one, to-many and many-to-many.
The left side of a relationship is where the relationship is declared, the right side is the resource type it points to.

## HasOne

This exposes a to-one relationship.

```c#
#nullable enable

public class TodoItem : Identifiable<int>
{
    [HasOne]
    public Person? Owner { get; set; }
}
```

The left side of this relationship is of type `TodoItem` (public name: "todoItems") and the right side is of type `Person` (public name: "persons").

### Required one-to-one relationships in Entity Framework Core

By default, Entity Framework Core generates an identifying foreign key for a required 1-to-1 relationship.
This means no foreign key column is generated, instead the primary keys point to each other directly.

The next example defines that each car requires an engine, while an engine is optionally linked to a car.

```c#
#nullable enable

public sealed class Car : Identifiable<int>
{
    [HasOne]
    public Engine Engine { get; set; } = null!;
}

public sealed class Engine : Identifiable<int>
{
    [HasOne]
    public Car? Car { get; set; }
}

public sealed class AppDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder builder)
    {
        builder.Entity<Car>()
            .HasOne(car => car.Engine)
            .WithOne(engine => engine.Car)
            .HasForeignKey<Car>()
            .IsRequired();
    }
}
```

Which results in Entity Framework Core generating the next database objects:
```sql
CREATE TABLE "Engine" (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    CONSTRAINT "PK_Engine" PRIMARY KEY ("Id")
);
CREATE TABLE "Cars" (
    "Id" integer NOT NULL,
    CONSTRAINT "PK_Cars" PRIMARY KEY ("Id"),
    CONSTRAINT "FK_Cars_Engine_Id" FOREIGN KEY ("Id") REFERENCES "Engine" ("Id")
        ON DELETE CASCADE
);
```

That mechanism does not make sense for JSON:API, because patching a relationship would result in also
changing the identity of a resource. Naming the foreign key explicitly fixes the problem by forcing to
create a foreign key column.

```c#
protected override void OnModelCreating(ModelBuilder builder)
{
    builder.Entity<Car>()
        .HasOne(car => car.Engine)
        .WithOne(engine => engine.Car)
        .HasForeignKey<Car>("EngineId") // Explicit foreign key name added
        .IsRequired();
}
```

Which generates the correct database objects:
```sql
CREATE TABLE "Engine" (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    CONSTRAINT "PK_Engine" PRIMARY KEY ("Id")
);
CREATE TABLE "Cars" (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    "EngineId" integer NOT NULL,
    CONSTRAINT "PK_Cars" PRIMARY KEY ("Id"),
    CONSTRAINT "FK_Cars_Engine_EngineId" FOREIGN KEY ("EngineId") REFERENCES "Engine" ("Id")
        ON DELETE CASCADE
);
CREATE UNIQUE INDEX "IX_Cars_EngineId" ON "Cars" ("EngineId");
```

## HasMany

This exposes a to-many relationship.

```c#
public class Person : Identifiable<int>
{
    [HasMany]
    public ICollection<TodoItem> TodoItems { get; set; } = new HashSet<TodoItem>();
}
```

The left side of this relationship is of type `Person` (public name: "persons") and the right side is of type `TodoItem` (public name: "todoItems").

## HasManyThrough

_removed since v5.0_

Earlier versions of Entity Framework Core (up to v5) [did not support](https://github.com/aspnet/EntityFrameworkCore/issues/1368) many-to-many relationships without a join entity.
For this reason, earlier versions of JsonApiDotNetCore filled this gap by allowing applications to declare a relationship as `HasManyThrough`,
which would expose the relationship to the client the same way as any other `HasMany` relationship.
However, under the covers it would use the join type and Entity Framework Core's APIs to get and set the relationship.

```c#
#nullable disable

public class Article : Identifiable<int>
{
    // tells Entity Framework Core to ignore this property
    [NotMapped]

    // tells JsonApiDotNetCore to use the join table below
    [HasManyThrough(nameof(ArticleTags))]
    public ICollection<Tag> Tags { get; set; }

    // this is the Entity Framework Core navigation to the join table
    public ICollection<ArticleTag> ArticleTags { get; set; }
}
```

The left side of this relationship is of type `Article` (public name: "articles") and the right side is of type `Tag` (public name: "tags").

## Name

There are two ways the exposed relationship name is determined:

1. Using the configured [naming convention](~/usage/options.md#customize-serializer-options).

2. Individually using the attribute's constructor.
```c#
#nullable enable
public class TodoItem : Identifiable<int>
{
    [HasOne(PublicName = "item-owner")]
    public Person Owner { get; set; } = null!;
}
```

## Includibility

Relationships can be marked to disallow including them using the `?include=` query string parameter. When not allowed, it results in an HTTP 400 response.

```c#
#nullable enable

public class TodoItem : Identifiable<int>
{
    [HasOne(CanInclude: false)]
    public Person? Owner { get; set; }
}
```

# Eager loading

_since v4.0_

Your resource may expose a calculated property, whose value depends on a related entity that is not exposed as a JSON:API resource.
So for the calculated property to be evaluated correctly, the related entity must always be retrieved. You can achieve that using `EagerLoad`, for example:

```c#
#nullable enable

public class ShippingAddress : Identifiable<int>
{
    [Attr]
    public string Street { get; set; } = null!;

    [Attr]
    public string? CountryName => Country?.DisplayName;

    // not exposed as resource, but adds .Include("Country") to the query
    [EagerLoad]
    public Country? Country { get; set; }
}

public class Country
{
    public string IsoCode { get; set; } = null!;
    public string DisplayName { get; set; } = null!;
}
```
