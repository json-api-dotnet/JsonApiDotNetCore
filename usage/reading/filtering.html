<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Filtering </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Filtering ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/json-api-dotnet/JsonApiDotNetCore/blob/master/docs/usage/reading/filtering.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="filtering">Filtering</h1>

<p><em>since v4.0</em></p>
<p>Resources can be filtered by attributes using the <code>filter</code> query string parameter.
By default, all attributes are filterable.
The filtering strategy we have selected, uses the following form.</p>
<pre><code>?filter=expression
</code></pre>
<p>Expressions are composed using the following functions:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Function</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Equality</td>
<td><code>equals</code></td>
<td><code>?filter=equals(lastName,'Smith')</code></td>
</tr>
<tr>
<td>Less than</td>
<td><code>lessThan</code></td>
<td><code>?filter=lessThan(age,'25')</code></td>
</tr>
<tr>
<td>Less than or equal to</td>
<td><code>lessOrEqual</code></td>
<td><code>?filter=lessOrEqual(lastModified,'2001-01-01')</code></td>
</tr>
<tr>
<td>Greater than</td>
<td><code>greaterThan</code></td>
<td><code>?filter=greaterThan(duration,'6:12:14')</code></td>
</tr>
<tr>
<td>Greater than or equal to</td>
<td><code>greaterOrEqual</code></td>
<td><code>?filter=greaterOrEqual(percentage,'33.33')</code></td>
</tr>
<tr>
<td>Contains text</td>
<td><code>contains</code></td>
<td><code>?filter=contains(description,'cooking')</code></td>
</tr>
<tr>
<td>Starts with text</td>
<td><code>startsWith</code></td>
<td><code>?filter=startsWith(description,'The')</code></td>
</tr>
<tr>
<td>Ends with text</td>
<td><code>endsWith</code></td>
<td><code>?filter=endsWith(description,'End')</code></td>
</tr>
<tr>
<td>Equals one value from set</td>
<td><code>any</code></td>
<td><code>?filter=any(chapter,'Intro','Summary','Conclusion')</code></td>
</tr>
<tr>
<td>Collection contains items</td>
<td><code>has</code></td>
<td><code>?filter=has(articles)</code></td>
</tr>
<tr>
<td>Type-check derived type (v5)</td>
<td><code>isType</code></td>
<td><code>?filter=isType(,men)</code></td>
</tr>
<tr>
<td>Negation</td>
<td><code>not</code></td>
<td><code>?filter=not(equals(lastName,null))</code></td>
</tr>
<tr>
<td>Conditional logical OR</td>
<td><code>or</code></td>
<td><code>?filter=or(has(orders),has(invoices))</code></td>
</tr>
<tr>
<td>Conditional logical AND</td>
<td><code>and</code></td>
<td><code>?filter=and(has(orders),has(invoices))</code></td>
</tr>
</tbody>
</table>
<p>Comparison operators compare an attribute against a constant value (between quotes), null or another attribute:</p>
<pre><code class="lang-http">GET /users?filter=equals(displayName,'Brian O''Connor') HTTP/1.1
</code></pre>
<pre><code class="lang-http">GET /users?filter=equals(displayName,null) HTTP/1.1
</code></pre>
<pre><code class="lang-http">GET /users?filter=equals(displayName,lastName) HTTP/1.1
</code></pre>
<p>Comparison operators can be combined with the <code>count</code> function, which acts on to-many relationships:</p>
<pre><code class="lang-http">GET /blogs?filter=lessThan(count(owner.articles),'10') HTTP/1.1
</code></pre>
<pre><code class="lang-http">GET /customers?filter=greaterThan(count(orders),count(invoices)) HTTP/1.1
</code></pre>
<p>When filters are used multiple times on the same resource, they are combined using an OR operator.
The next request returns all customers that have orders -or- whose last name is Smith.</p>
<pre><code class="lang-http">GET /customers?filter=has(orders)&amp;filter=equals(lastName,'Smith') HTTP/1.1
</code></pre>
<p>Aside from filtering on the resource being requested (which would be blogs in /blogs and articles in /blogs/1/articles),
filtering on to-many relationships can be done using bracket notation:</p>
<pre><code class="lang-http">GET /articles?include=author,tags&amp;filter=equals(author.lastName,'Smith')&amp;filter[tags]=any(label,'tech','design') HTTP/1.1
</code></pre>
<p>In the above request, the first filter is applied on the collection of articles, while the second one is applied on the nested collection of tags.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>The request above does <strong>not</strong> hide articles without any matching tags! Use the <code>has</code> function with a filter condition (see below) to accomplish that.</p>
</div>
<p>Putting it all together, you can build quite complex filters, such as:</p>
<pre><code class="lang-http">GET /blogs?include=owner.articles.revisions&amp;filter=and(or(equals(title,'Technology'),has(owner.articles)),not(equals(owner.lastName,null)))&amp;filter[owner.articles]=equals(caption,'Two')&amp;filter[owner.articles.revisions]=greaterThan(publishTime,'2005-05-05') HTTP/1.1
</code></pre>
<p><em>since v4.2</em></p>
<p>The <code>has</code> function takes an optional filter condition as second parameter, for example:</p>
<pre><code class="lang-http">GET /customers?filter=has(orders,not(equals(status,'Paid'))) HTTP/1.1
</code></pre>
<p>Which returns only customers that have at least one unpaid order.</p>
<p><em>since v5.0</em></p>
<p>Use the <code>isType</code> filter function to perform a type check on a derived type. You can pass a nested filter, where the derived fields are accessible.</p>
<p>Only return men:</p>
<pre><code class="lang-http">GET /humans?filter=isType(,men) HTTP/1.1
</code></pre>
<p>Only return men with beards:</p>
<pre><code class="lang-http">GET /humans?filter=isType(,men,equals(hasBeard,'true')) HTTP/1.1
</code></pre>
<p>The first parameter of <code>isType</code> can be used to perform the type check on a to-one relationship path.</p>
<p>Only return people whose best friend is a man with children:</p>
<pre><code class="lang-http">GET /humans?filter=isType(bestFriend,men,has(children)) HTTP/1.1
</code></pre>
<p>Only return people who have at least one female married child:</p>
<pre><code class="lang-http">GET /humans?filter=has(children,isType(,woman,not(equals(husband,null)))) HTTP/1.1
</code></pre>
<h1 id="legacy-filters">Legacy filters</h1>
<p>The next section describes how filtering worked in versions prior to v4.0. They are always applied on the set of resources being requested (no nesting).
Legacy filters use the following form.</p>
<pre><code>?filter[attribute]=value
</code></pre>
<p>For operations other than equality, the query can be prefixed with an operation identifier.
Examples can be found in the table below.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Prefix</th>
<th>Example</th>
<th>Equivalent form in v4.0</th>
</tr>
</thead>
<tbody>
<tr>
<td>Equality</td>
<td><code>eq</code></td>
<td><code>?filter[lastName]=eq:Smith</code></td>
<td><code>?filter=equals(lastName,'Smith')</code></td>
</tr>
<tr>
<td>Non-equality</td>
<td><code>ne</code></td>
<td><code>?filter[lastName]=ne:Smith</code></td>
<td><code>?filter=not(equals(lastName,'Smith'))</code></td>
</tr>
<tr>
<td>Less than</td>
<td><code>lt</code></td>
<td><code>?filter[age]=lt:25</code></td>
<td><code>?filter=lessThan(age,'25')</code></td>
</tr>
<tr>
<td>Less than or equal to</td>
<td><code>le</code></td>
<td><code>?filter[lastModified]=le:2001-01-01</code></td>
<td><code>?filter=lessOrEqual(lastModified,'2001-01-01')</code></td>
</tr>
<tr>
<td>Greater than</td>
<td><code>gt</code></td>
<td><code>?filter[duration]=gt:6:12:14</code></td>
<td><code>?filter=greaterThan(duration,'6:12:14')</code></td>
</tr>
<tr>
<td>Greater than or equal to</td>
<td><code>ge</code></td>
<td><code>?filter[percentage]=ge:33.33</code></td>
<td><code>?filter=greaterOrEqual(percentage,'33.33')</code></td>
</tr>
<tr>
<td>Contains text</td>
<td><code>like</code></td>
<td><code>?filter[description]=like:cooking</code></td>
<td><code>?filter=contains(description,'cooking')</code></td>
</tr>
<tr>
<td>Equals one value from set</td>
<td><code>in</code></td>
<td><code>?filter[chapter]=in:Intro,Summary,Conclusion</code></td>
<td><code>?filter=any(chapter,'Intro','Summary','Conclusion')</code></td>
</tr>
<tr>
<td>Equals none from set</td>
<td><code>nin</code></td>
<td><code>?filter[chapter]=nin:one,two,three</code></td>
<td><code>?filter=not(any(chapter,'one','two','three'))</code></td>
</tr>
<tr>
<td>Equal to null</td>
<td><code>isnull</code></td>
<td><code>?filter[lastName]=isnull:</code></td>
<td><code>?filter=equals(lastName,null)</code></td>
</tr>
<tr>
<td>Not equal to null</td>
<td><code>isnotnull</code></td>
<td><code>?filter[lastName]=isnotnull:</code></td>
<td><code>?filter=not(equals(lastName,null))</code></td>
</tr>
</tbody>
</table>
<p>Filters can be combined and will be applied using an OR operator. This used to be AND in versions prior to v4.0.</p>
<p>Attributes to filter on can optionally be prefixed with to-one relationships, for example:</p>
<pre><code class="lang-http">GET /api/articles?include=author&amp;filter[caption]=like:marketing&amp;filter[author.lastName]=Smith HTTP/1.1
</code></pre>
<p>Legacy filter notation can still be used in v4.0 by setting <code>options.EnableLegacyFilterNotation</code> to <code>true</code>.
If you want to use the new filter notation in that case, prefix the parameter value with <code>expr:</code>, for example:</p>
<pre><code class="lang-http">GET /articles?filter[caption]=tech&amp;filter=expr:equals(caption,'cooking')) HTTP/1.1
</code></pre>
<h1 id="custom-filters">Custom Filters</h1>
<p>There are multiple ways you can add custom filters:</p>
<ol>
<li>Implementing <code>IResourceDefinition.OnApplyFilter</code> (see <a href="../extensibility/resource-definitions.html#change-filters">here</a>) and inject <code>IRequestQueryStringAccessor</code>, which works at all depths, but filter operations are constrained to what <code>FilterExpression</code> provides</li>
<li>Implementing <code>IResourceDefinition.OnRegisterQueryableHandlersForQueryStringParameters</code> as described <a href="../extensibility/resource-definitions.html#custom-query-string-parameters">here</a>, which enables the full range of <code>IQueryable&lt;T&gt;</code> functionality, but only works on primary endpoints</li>
<li>Add an implementation of <code>IQueryConstraintProvider</code> to supply additional <code>FilterExpression</code>s, which are combined with existing filters using AND operator</li>
<li>Override <code>EntityFrameworkCoreRepository.ApplyQueryLayer</code> to adapt the <code>IQueryable&lt;T&gt;</code> expression just before execution</li>
<li>Take a deep dive and plug into reader/parser/tokenizer/visitor/builder for adding additional general-purpose filter operators</li>
</ol>
<h1 id="filter-syntax">Filter syntax</h1>
<p>For reference, we provide the EBNF grammar for filter expressions below (in <a href="https://github.com/antlr/antlr4">ANTLR4</a> style):</p>
<pre><code class="lang-ebnf">grammar Filter;

filterExpression:
    notExpression
    | logicalExpression
    | comparisonExpression
    | matchTextExpression
    | anyExpression
    | hasExpression;

notExpression:
    'not' LPAREN filterExpression RPAREN;

logicalExpression:
    ( 'and' | 'or' ) LPAREN filterExpression ( COMMA filterExpression )* RPAREN;

comparisonExpression:
    ( 'equals' | 'greaterThan' | 'greaterOrEqual' | 'lessThan' | 'lessOrEqual' ) LPAREN (
        countExpression | fieldChain
    ) COMMA (
        countExpression | literalConstant | 'null' | fieldChain
    ) RPAREN;

matchTextExpression:
    ( 'contains' | 'startsWith' | 'endsWith' ) LPAREN fieldChain COMMA literalConstant RPAREN;

anyExpression:
    'any' LPAREN fieldChain ( COMMA literalConstant )+ RPAREN;

hasExpression:
    'has' LPAREN fieldChain ( COMMA filterExpression )? RPAREN;

countExpression:
    'count' LPAREN fieldChain RPAREN;

fieldChain:
    FIELD ( '.' FIELD )*;

literalConstant:
    ESCAPED_TEXT;

LPAREN: '(';
RPAREN: ')';
COMMA: ',';

fragment OUTER_FIELD_CHARACTER: [A-Za-z0-9];
fragment INNER_FIELD_CHARACTER: [A-Za-z0-9_-];
FIELD: OUTER_FIELD_CHARACTER ( INNER_FIELD_CHARACTER* OUTER_FIELD_CHARACTER )?;

ESCAPED_TEXT: '\'' ( ~['] | '\'\'' )* '\'' ;

LINE_BREAKS: [\r\n]+ -&gt; skip;
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/json-api-dotnet/JsonApiDotNetCore/blob/master/docs/usage/reading/filtering.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
