<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Relationships </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Relationships ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/json-api-dotnet/JsonApiDotNetCore/blob/master/docs/usage/resources/relationships.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="relationships">Relationships</h1>

<p>A relationship is a named link between two resource types, including a direction.
They are similar to <a href="https://docs.microsoft.com/en-us/ef/core/modeling/relationships">navigation properties in Entity Framework Core</a>.</p>
<p>Relationships come in two flavors: to-one and to-many.
The left side of a relationship is where the relationship is declared, the right side is the resource type it points to.</p>
<h2 id="hasone">HasOne</h2>
<p>This exposes a to-one relationship.</p>
<pre><code class="lang-c#">#nullable enable

public class TodoItem : Identifiable&lt;int&gt;
{
    [HasOne]
    public Person? Owner { get; set; }
}
</code></pre>
<p>The left side of this relationship is of type <code>TodoItem</code> (public name: &quot;todoItems&quot;) and the right side is of type <code>Person</code> (public name: &quot;persons&quot;).</p>
<h3 id="one-to-one-relationships-in-entity-framework-core">One-to-one relationships in Entity Framework Core</h3>
<p>By default, Entity Framework Core tries to generate an <em>identifying foreign key</em> for a one-to-one relationship whenever possible.
In that case, no foreign key column is generated. Instead the primary keys point to each other directly.</p>
<p><strong>That mechanism does not make sense for JSON:API, because patching a relationship would result in also
changing the identity of a resource. Naming the foreign key explicitly fixes the problem, which enforces
to create a foreign key column.</strong></p>
<p>The next example defines that each car requires an engine, while an engine is optionally linked to a car.</p>
<pre><code class="lang-c#">#nullable enable

public sealed class Car : Identifiable&lt;int&gt;
{
    [HasOne]
    public Engine Engine { get; set; } = null!;
}

public sealed class Engine : Identifiable&lt;int&gt;
{
    [HasOne]
    public Car? Car { get; set; }
}

public sealed class AppDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder builder)
    {
        builder.Entity&lt;Car&gt;()
            .HasOne(car =&gt; car.Engine)
            .WithOne(engine =&gt; engine.Car)
            .HasForeignKey&lt;Car&gt;();
    }
}
</code></pre>
<p>Which results in Entity Framework Core generating the next database objects:</p>
<pre><code class="lang-sql">CREATE TABLE &quot;Engine&quot; (
    &quot;Id&quot; integer GENERATED BY DEFAULT AS IDENTITY,
    CONSTRAINT &quot;PK_Engine&quot; PRIMARY KEY (&quot;Id&quot;)
);

CREATE TABLE &quot;Cars&quot; (
    &quot;Id&quot; integer NOT NULL,
    CONSTRAINT &quot;PK_Cars&quot; PRIMARY KEY (&quot;Id&quot;),
    CONSTRAINT &quot;FK_Cars_Engine_Id&quot; FOREIGN KEY (&quot;Id&quot;) REFERENCES &quot;Engine&quot; (&quot;Id&quot;)
        ON DELETE CASCADE
);
</code></pre>
<p>To fix this, name the foreign key explicitly:</p>
<pre><code class="lang-c#">protected override void OnModelCreating(ModelBuilder builder)
{
    builder.Entity&lt;Car&gt;()
        .HasOne(car =&gt; car.Engine)
        .WithOne(engine =&gt; engine.Car)
        .HasForeignKey&lt;Car&gt;(&quot;EngineId&quot;); // &lt;-- Explicit foreign key name added
}
</code></pre>
<p>Which generates the correct database objects:</p>
<pre><code class="lang-sql">CREATE TABLE &quot;Engine&quot; (
    &quot;Id&quot; integer GENERATED BY DEFAULT AS IDENTITY,
    CONSTRAINT &quot;PK_Engine&quot; PRIMARY KEY (&quot;Id&quot;)
);

CREATE TABLE &quot;Cars&quot; (
    &quot;Id&quot; integer GENERATED BY DEFAULT AS IDENTITY,
    &quot;EngineId&quot; integer NOT NULL,
    CONSTRAINT &quot;PK_Cars&quot; PRIMARY KEY (&quot;Id&quot;),
    CONSTRAINT &quot;FK_Cars_Engine_EngineId&quot; FOREIGN KEY (&quot;EngineId&quot;) REFERENCES &quot;Engine&quot; (&quot;Id&quot;)
        ON DELETE CASCADE
);

CREATE UNIQUE INDEX &quot;IX_Cars_EngineId&quot; ON &quot;Cars&quot; (&quot;EngineId&quot;);
</code></pre>
<h4 id="optional-one-to-one-relationships-in-entity-framework-core">Optional one-to-one relationships in Entity Framework Core</h4>
<p>For optional one-to-one relationships, Entity Framework Core uses <code>DeleteBehavior.ClientSetNull</code> by default, instead of <code>DeleteBehavior.SetNull</code>.
This means that Entity Framework Core tries to handle the cascading effects (by sending multiple SQL statements), instead of leaving it up to the database.
Of course that's only going to work when all the related resources are loaded in the change tracker upfront, which is expensive because it requires fetching more data than necessary.</p>
<p>The reason for this odd default is poor support in SQL Server, as explained <a href="https://stackoverflow.com/questions/54326165/ef-core-why-clientsetnull-is-default-ondelete-behavior-for-optional-relations">here</a> and <a href="https://learn.microsoft.com/en-us/ef/core/saving/cascade-delete#database-cascade-limitations">here</a>.</p>
<p><strong>Our <a href="https://github.com/json-api-dotnet/JsonApiDotNetCore/pull/1205">testing</a> shows that these limitations don't exist when using PostgreSQL.
Therefore the general advice is to map the delete behavior of optional one-to-one relationships explicitly with <code>.OnDelete(DeleteBehavior.SetNull)</code>. This is simpler and more efficient.</strong></p>
<p>The next example defines that each car optionally has an engine, while an engine is optionally linked to a car.</p>
<pre><code class="lang-c#">#nullable enable

public sealed class Car : Identifiable&lt;int&gt;
{
    [HasOne]
    public Engine? Engine { get; set; }
}

public sealed class Engine : Identifiable&lt;int&gt;
{
    [HasOne]
    public Car? Car { get; set; }
}

public sealed class AppDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder builder)
    {
        builder.Entity&lt;Car&gt;()
            .HasOne(car =&gt; car.Engine)
            .WithOne(engine =&gt; engine.Car)
            .HasForeignKey&lt;Car&gt;(&quot;EngineId&quot;);
    }
}
</code></pre>
<p>Which results in Entity Framework Core generating the next database objects:</p>
<pre><code class="lang-sql">CREATE TABLE &quot;Engines&quot; (
    &quot;Id&quot; integer GENERATED BY DEFAULT AS IDENTITY,
    CONSTRAINT &quot;PK_Engines&quot; PRIMARY KEY (&quot;Id&quot;)
);

CREATE TABLE &quot;Cars&quot; (
    &quot;Id&quot; integer GENERATED BY DEFAULT AS IDENTITY,
    &quot;EngineId&quot; integer NULL,
    CONSTRAINT &quot;PK_Cars&quot; PRIMARY KEY (&quot;Id&quot;),
    CONSTRAINT &quot;FK_Cars_Engines_EngineId&quot; FOREIGN KEY (&quot;EngineId&quot;) REFERENCES &quot;Engines&quot; (&quot;Id&quot;)
);

CREATE UNIQUE INDEX &quot;IX_Cars_EngineId&quot; ON &quot;Cars&quot; (&quot;EngineId&quot;);
</code></pre>
<p>To fix this, set the delete behavior explicitly:</p>
<pre><code>public sealed class AppDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder builder)
    {
        builder.Entity&lt;Car&gt;()
            .HasOne(car =&gt; car.Engine)
            .WithOne(engine =&gt; engine.Car)
            .HasForeignKey&lt;Car&gt;(&quot;EngineId&quot;)
            .OnDelete(DeleteBehavior.SetNull); // &lt;-- Explicit delete behavior set
    }
}
</code></pre>
<p>Which generates the correct database objects:</p>
<pre><code class="lang-sql">CREATE TABLE &quot;Engines&quot; (
    &quot;Id&quot; integer GENERATED BY DEFAULT AS IDENTITY,
    CONSTRAINT &quot;PK_Engines&quot; PRIMARY KEY (&quot;Id&quot;)
);

CREATE TABLE &quot;Cars&quot; (
    &quot;Id&quot; integer GENERATED BY DEFAULT AS IDENTITY,
    &quot;EngineId&quot; integer NULL,
    CONSTRAINT &quot;PK_Cars&quot; PRIMARY KEY (&quot;Id&quot;),
    CONSTRAINT &quot;FK_Cars_Engines_EngineId&quot; FOREIGN KEY (&quot;EngineId&quot;) REFERENCES &quot;Engines&quot; (&quot;Id&quot;) ON DELETE SET NULL
);

CREATE UNIQUE INDEX &quot;IX_Cars_EngineId&quot; ON &quot;Cars&quot; (&quot;EngineId&quot;);
</code></pre>
<h2 id="hasmany">HasMany</h2>
<p>This exposes a to-many relationship.</p>
<pre><code class="lang-c#">public class Person : Identifiable&lt;int&gt;
{
    [HasMany]
    public ICollection&lt;TodoItem&gt; TodoItems { get; set; } = new HashSet&lt;TodoItem&gt;();
}
</code></pre>
<p>The left side of this relationship is of type <code>Person</code> (public name: &quot;persons&quot;) and the right side is of type <code>TodoItem</code> (public name: &quot;todoItems&quot;).</p>
<h2 id="hasmanythrough">HasManyThrough</h2>
<p><em>removed since v5.0</em></p>
<p>Earlier versions of Entity Framework Core (up to v5) <a href="https://github.com/aspnet/EntityFrameworkCore/issues/1368">did not support</a> many-to-many relationships without a join entity.
For this reason, earlier versions of JsonApiDotNetCore filled this gap by allowing applications to declare a relationship as <code>HasManyThrough</code>,
which would expose the relationship to the client the same way as any other <code>HasMany</code> relationship.
However, under the covers it would use the join type and Entity Framework Core's APIs to get and set the relationship.</p>
<pre><code class="lang-c#">#nullable disable

public class Article : Identifiable&lt;int&gt;
{
    // tells Entity Framework Core to ignore this property
    [NotMapped]

    // tells JsonApiDotNetCore to use the join table below
    [HasManyThrough(nameof(ArticleTags))]
    public ICollection&lt;Tag&gt; Tags { get; set; }

    // this is the Entity Framework Core navigation to the join table
    public ICollection&lt;ArticleTag&gt; ArticleTags { get; set; }
}
</code></pre>
<p>The left side of this relationship is of type <code>Article</code> (public name: &quot;articles&quot;) and the right side is of type <code>Tag</code> (public name: &quot;tags&quot;).</p>
<h2 id="name">Name</h2>
<p>There are two ways the exposed relationship name is determined:</p>
<ol>
<li><p>Using the configured <a href="../options.html#customize-serializer-options">naming convention</a>.</p>
</li>
<li><p>Individually using the attribute's constructor.</p>
</li>
</ol>
<pre><code class="lang-c#">#nullable enable
public class TodoItem : Identifiable&lt;int&gt;
{
    [HasOne(PublicName = &quot;item-owner&quot;)]
    public Person Owner { get; set; } = null!;
}
</code></pre>
<h2 id="capabilities">Capabilities</h2>
<p><em>since v5.1</em></p>
<p>Default JSON:API relationship capabilities are specified in
<a class="xref" href="../../api/JsonApiDotNetCore.Configuration.JsonApiOptions.html#JsonApiDotNetCore_Configuration_JsonApiOptions_DefaultHasOneCapabilities">JsonApiOptions</a> and
<a class="xref" href="../../api/JsonApiDotNetCore.Configuration.JsonApiOptions.html#JsonApiDotNetCore_Configuration_JsonApiOptions_DefaultHasManyCapabilities">JsonApiOptions</a>:</p>
<pre><code class="lang-c#">options.DefaultHasOneCapabilities = HasOneCapabilities.None; // default: All
options.DefaultHasManyCapabilities = HasManyCapabilities.None; // default: All
</code></pre>
<p>This can be overridden per relationship.</p>
<h3 id="allowview">AllowView</h3>
<p>Indicates whether the relationship can be returned in responses. When not allowed and requested using <code>?fields[]=</code>, it results in an HTTP 400 response.
Otherwise, the relationship (and its related resources, when included) are silently omitted.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>This setting does not affect retrieving the related resources directly.</p>
</div>
<pre><code class="lang-c#">#nullable enable

public class User : Identifiable&lt;int&gt;
{
    [HasOne(Capabilities = ~HasOneCapabilities.AllowView)]
    public LoginAccount Account { get; set; } = null!;
}
</code></pre>
<h3 id="allowinclude">AllowInclude</h3>
<p>Indicates whether the relationship can be included. When not allowed and used in <code>?include=</code>, an HTTP 400 is returned.</p>
<pre><code class="lang-c#">#nullable enable

public class User : Identifiable&lt;int&gt;
{
    [HasMany(Capabilities = ~HasManyCapabilities.AllowInclude)]
    public ISet&lt;Group&gt; Groups { get; set; } = new HashSet&lt;Group&gt;();
}
</code></pre>
<h3 id="allowfilter">AllowFilter</h3>
<p>For to-many relationships only. Indicates whether it can be used in the <code>count()</code> and <code>has()</code> filter functions. When not allowed and used in <code>?filter=</code>, an HTTP 400 is returned.</p>
<pre><code class="lang-c#">#nullable enable

public class User : Identifiable&lt;int&gt;
{
    [HasMany(Capabilities = HasManyCapabilities.AllowFilter)]
    public ISet&lt;Group&gt; Groups { get; set; } = new HashSet&lt;Group&gt;();
}
</code></pre>
<h3 id="allowset">AllowSet</h3>
<p>Indicates whether POST and PATCH requests can replace the relationship. When sent but not allowed, an HTTP 422 response is returned.</p>
<pre><code class="lang-c#">#nullable enable

public class User : Identifiable&lt;int&gt;
{
    [HasOne(Capabilities = ~HasOneCapabilities.AllowSet)]
    public LoginAccount Account { get; set; } = null!;
}
</code></pre>
<h3 id="allowadd">AllowAdd</h3>
<p>For to-many relationships only. Indicates whether POST requests can add resources to the relationship. When sent but not allowed, an HTTP 422 response is returned.</p>
<pre><code class="lang-c#">#nullable enable

public class User : Identifiable&lt;int&gt;
{
    [HasMany(Capabilities = ~HasManyCapabilities.AllowAdd)]
    public ISet&lt;Group&gt; Groups { get; set; } = new HashSet&lt;Group&gt;();
}
</code></pre>
<h3 id="allowremove">AllowRemove</h3>
<p>For to-many relationships only. Indicates whether DELETE requests can remove resources from the relationship. When sent but not allowed, an HTTP 422 response is returned.</p>
<pre><code class="lang-c#">#nullable enable

public class User : Identifiable&lt;int&gt;
{
    [HasMany(Capabilities = ~HasManyCapabilities.AllowRemove)]
    public ISet&lt;Group&gt; Groups { get; set; } = new HashSet&lt;Group&gt;();
}
</code></pre>
<h2 id="caninclude">CanInclude</h2>
<p><em>obsolete since v5.1</em></p>
<p>Relationships can be marked to disallow including them using the <code>?include=</code> query string parameter. When not allowed, it results in an HTTP 400 response.</p>
<pre><code class="lang-c#">#nullable enable

public class TodoItem : Identifiable&lt;int&gt;
{
    [HasOne(CanInclude: false)]
    public Person? Owner { get; set; }
}
</code></pre>
<h1 id="eager-loading">Eager loading</h1>
<p><em>since v4.0</em></p>
<p>Your resource may expose a calculated property, whose value depends on a related entity that is not exposed as a JSON:API resource.
So for the calculated property to be evaluated correctly, the related entity must always be retrieved. You can achieve that using <code>EagerLoad</code>, for example:</p>
<pre><code class="lang-c#">#nullable enable

public class ShippingAddress : Identifiable&lt;int&gt;
{
    [Attr]
    public string Street { get; set; } = null!;

    [Attr]
    public string? CountryName =&gt; Country?.DisplayName;

    // not exposed as resource, but adds .Include(&quot;Country&quot;) to the query
    [EagerLoad]
    public Country? Country { get; set; }
}

public class Country
{
    public string IsoCode { get; set; } = null!;
    public string DisplayName { get; set; } = null!;
}
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/json-api-dotnet/JsonApiDotNetCore/blob/master/docs/usage/resources/relationships.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
