<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Attributes </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Attributes ">
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/json-api-dotnet/JsonApiDotNetCore/blob/master/docs/usage/resources/attributes.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
  </head>

  <script type="module">
    import options from './../../public/main.js'
    import { init } from './../../public/docfx.min.js'
    init(options)
  </script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="attributes">Attributes</h1>

<p>If you want an attribute on your model to be publicly available, add the <code>AttrAttribute</code>.</p>
<pre><code class="lang-c#">#nullable enable

public class Person : Identifiable&lt;int&gt;
{
    [Attr]
    public string? FirstName { get; set; }

    [Attr]
    public string LastName { get; set; } = null!;
}
</code></pre>
<h2 id="name">Name</h2>
<p>There are two ways the exposed attribute name is determined:</p>
<ol>
<li><p>Using the configured <a href="../options.html#customize-serializer-options">naming convention</a>.</p>
</li>
<li><p>Individually using the attribute's constructor.</p>
</li>
</ol>
<pre><code class="lang-c#">#nullable enable
public class Person : Identifiable&lt;int&gt;
{
    [Attr(PublicName = &quot;first-name&quot;)]
    public string? FirstName { get; set; }
}
</code></pre>
<h2 id="capabilities">Capabilities</h2>
<p><em>since v4.0</em></p>
<p>Default JSON:API attribute capabilities are specified in <a class="xref" href="../../api/JsonApiDotNetCore.Configuration.JsonApiOptions.html#JsonApiDotNetCore_Configuration_JsonApiOptions_DefaultAttrCapabilities">JsonApiOptions</a>:</p>
<pre><code class="lang-c#">options.DefaultAttrCapabilities = AttrCapabilities.None; // default: All
</code></pre>
<p>This can be overridden per attribute.</p>
<h3 id="allowview">AllowView</h3>
<p>Indicates whether the attribute value can be returned in responses. When not allowed and requested using <code>?fields[]=</code>, it results in an HTTP 400 response.
Otherwise, the attribute is silently omitted.</p>
<pre><code class="lang-c#">#nullable enable

public class User : Identifiable&lt;int&gt;
{
    [Attr(Capabilities = ~AttrCapabilities.AllowView)]
    public string Password { get; set; } = null!;
}
</code></pre>
<h3 id="allowfilter">AllowFilter</h3>
<p>Indicates whether the attribute can be filtered on. When not allowed and used in <code>?filter=</code>, an HTTP 400 is returned.</p>
<pre><code class="lang-c#">#nullable enable

public class Person : Identifiable&lt;int&gt;
{
    [Attr(Capabilities = AttrCapabilities.AllowFilter)]
    public string? FirstName { get; set; }
}
</code></pre>
<h3 id="allowsort">AllowSort</h3>
<p>Indicates whether the attribute can be sorted on. When not allowed and used in <code>?sort=</code>, an HTTP 400 is returned.</p>
<pre><code class="lang-c#">#nullable enable

public class Person : Identifiable&lt;int&gt;
{
    [Attr(Capabilities = ~AttrCapabilities.AllowSort)]
    public string? FirstName { get; set; }
}
</code></pre>
<h3 id="allowcreate">AllowCreate</h3>
<p>Indicates whether POST requests can assign the attribute value. When sent but not allowed, an HTTP 422 response is returned.</p>
<pre><code class="lang-c#">#nullable enable

public class Person : Identifiable&lt;int&gt;
{
    [Attr(Capabilities = AttrCapabilities.AllowCreate)]
    public string? CreatorName { get; set; }
}
</code></pre>
<h3 id="allowchange">AllowChange</h3>
<p>Indicates whether PATCH requests can update the attribute value. When sent but not allowed, an HTTP 422 response is returned.</p>
<pre><code class="lang-c#">#nullable enable

public class Person : Identifiable&lt;int&gt;
{
    [Attr(Capabilities = AttrCapabilities.AllowChange)]
    public string? FirstName { get; set; };
}
</code></pre>
<h2 id="complex-attributes">Complex Attributes</h2>
<p>Models may contain complex attributes.
Serialization of these types is done by <a href="https://www.nuget.org/packages/System.Text.Json">System.Text.Json</a>,
so you should use their APIs to specify serialization format.
You can also use <a href="../options.html#customize-serializer-options">global options</a> to control the <code>JsonSerializer</code> behavior.</p>
<pre><code class="lang-c#">#nullable enable

public class Foo : Identifiable&lt;int&gt;
{
    [Attr]
    public Bar? Bar { get; set; }
}

public class Bar
{
    [JsonPropertyName(&quot;compound-member&quot;)]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? CompoundMember { get; set; }
}
</code></pre>
<p>If you need your complex attributes persisted as a
JSON string in your database, but you need access to it as a concrete type, you can define two members on your resource.
The first member is the concrete type that you will directly interact with in your application. You can use the <code>NotMapped</code> attribute to prevent Entity Framework Core from mapping it to the database. The second is the raw JSON property that will be persisted to the database. How you use these members should determine which one is responsible for serialization. In this example, we only serialize and deserialize at the time of persistence
and retrieval.</p>
<pre><code class="lang-c#">#nullable enable

public class Foo : Identifiable&lt;int&gt;
{
    [Attr]
    [NotMapped]
    public Bar? Bar { get; set; }

    public string? BarJson
    {
        get
        {
            return Bar == null ? &quot;{}&quot; : JsonSerializer.Serialize(Bar);
        }
        set
        {
            Bar = string.IsNullOrWhiteSpace(value)
                ? null
                : JsonSerializer.Deserialize&lt;Bar&gt;(value);
        }
    }
}
</code></pre>
</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/json-api-dotnet/JsonApiDotNetCore/blob/master/docs/usage/resources/attributes.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>
        
      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>