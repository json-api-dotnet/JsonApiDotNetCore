// This file was generated by liblab | https://liblab.com/

using System.Net.Http.Json;
using JsonApiDotNetCoreClientExample.Http;
using JsonApiDotNetCoreClientExample.Http.Serialization;
using JsonApiDotNetCoreClientExample.Models;

namespace JsonApiDotNetCoreClientExample.Services;

public class PeopleService : BaseService
{
    internal PeopleService(HttpClient httpClient)
        : base(httpClient) { }

    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task<PersonCollectionResponseDocument> GetPersonCollectionAsync(
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        var request = new RequestBuilder(HttpMethod.Get, "api/people")
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<PersonCollectionResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <param name="input">The attributes and relationships of the person to create.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    public async Task<PersonPrimaryResponseDocument> PostPersonAsync(
        PersonPostRequestDocument input,
        object? query = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));

        var request = new RequestBuilder(HttpMethod.Post, "api/people")
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<PersonPrimaryResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Compare the returned ETag HTTP header with an earlier one to determine if the response has changed since it was fetched.</summary>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task HeadPersonCollectionAsync(
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        var request = new RequestBuilder(HttpMethod.Head, "api/people")
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="id">The identifier of the person to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task<PersonPrimaryResponseDocument> GetPersonAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Get, "api/people/{id}")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<PersonPrimaryResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <param name="input">The attributes and relationships of the person to update. Omitted fields are left unchanged.</param>
    /// <param name="id">The identifier of the person to update.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    public async Task<PersonPrimaryResponseDocument> PatchPersonAsync(
        PersonPatchRequestDocument input,
        string id,
        object? query = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Patch, "api/people/{id}")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<PersonPrimaryResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <param name="id">The identifier of the person to delete.</param>
    public async Task DeletePersonAsync(string id, CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Delete, "api/people/{id}")
            .SetPathParameter("id", id)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <summary>Compare the returned ETag HTTP header with an earlier one to determine if the response has changed since it was fetched.</summary>
    /// <param name="id">The identifier of the person to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task HeadPersonAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Head, "api/people/{id}")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="id">The identifier of the person whose related todoItems to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task<TodoItemCollectionResponseDocument> GetPersonAssignedTodoItemsAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Get, "api/people/{id}/assignedTodoItems")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<TodoItemCollectionResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Compare the returned ETag HTTP header with an earlier one to determine if the response has changed since it was fetched.</summary>
    /// <param name="id">The identifier of the person whose related todoItems to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task HeadPersonAssignedTodoItemsAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Head, "api/people/{id}/assignedTodoItems")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="id">The identifier of the person whose related todoItem identities to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task<TodoItemIdentifierCollectionResponseDocument> GetPersonAssignedTodoItemsRelationshipAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(
            HttpMethod.Get,
            "api/people/{id}/relationships/assignedTodoItems"
        )
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<TodoItemIdentifierCollectionResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <param name="input">The identities of the todoItems to add to the assignedTodoItems relationship.</param>
    /// <param name="id">The identifier of the person to add todoItems to.</param>
    public async Task PostPersonAssignedTodoItemsRelationshipAsync(
        ToManyTodoItemInRequest input,
        string id,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(
            HttpMethod.Post,
            "api/people/{id}/relationships/assignedTodoItems"
        )
            .SetPathParameter("id", id)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="input">The identities of the todoItems to assign to the assignedTodoItems relationship, or an empty array to clear the relationship.</param>
    /// <param name="id">The identifier of the person whose assignedTodoItems relationship to assign.</param>
    public async Task PatchPersonAssignedTodoItemsRelationshipAsync(
        ToManyTodoItemInRequest input,
        string id,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(
            HttpMethod.Patch,
            "api/people/{id}/relationships/assignedTodoItems"
        )
            .SetPathParameter("id", id)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="input">The identities of the todoItems to remove from the assignedTodoItems relationship.</param>
    /// <param name="id">The identifier of the person to remove todoItems from.</param>
    public async Task DeletePersonAssignedTodoItemsRelationshipAsync(
        ToManyTodoItemInRequest input,
        string id,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(
            HttpMethod.Delete,
            "api/people/{id}/relationships/assignedTodoItems"
        )
            .SetPathParameter("id", id)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <summary>Compare the returned ETag HTTP header with an earlier one to determine if the response has changed since it was fetched.</summary>
    /// <param name="id">The identifier of the person whose related todoItem identities to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task HeadPersonAssignedTodoItemsRelationshipAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(
            HttpMethod.Head,
            "api/people/{id}/relationships/assignedTodoItems"
        )
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="id">The identifier of the person whose related todoItems to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task<TodoItemCollectionResponseDocument> GetPersonOwnedTodoItemsAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Get, "api/people/{id}/ownedTodoItems")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<TodoItemCollectionResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Compare the returned ETag HTTP header with an earlier one to determine if the response has changed since it was fetched.</summary>
    /// <param name="id">The identifier of the person whose related todoItems to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task HeadPersonOwnedTodoItemsAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Head, "api/people/{id}/ownedTodoItems")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="id">The identifier of the person whose related todoItem identities to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task<TodoItemIdentifierCollectionResponseDocument> GetPersonOwnedTodoItemsRelationshipAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(
            HttpMethod.Get,
            "api/people/{id}/relationships/ownedTodoItems"
        )
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<TodoItemIdentifierCollectionResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <param name="input">The identities of the todoItems to add to the ownedTodoItems relationship.</param>
    /// <param name="id">The identifier of the person to add todoItems to.</param>
    public async Task PostPersonOwnedTodoItemsRelationshipAsync(
        ToManyTodoItemInRequest input,
        string id,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(
            HttpMethod.Post,
            "api/people/{id}/relationships/ownedTodoItems"
        )
            .SetPathParameter("id", id)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="input">The identities of the todoItems to assign to the ownedTodoItems relationship, or an empty array to clear the relationship.</param>
    /// <param name="id">The identifier of the person whose ownedTodoItems relationship to assign.</param>
    public async Task PatchPersonOwnedTodoItemsRelationshipAsync(
        ToManyTodoItemInRequest input,
        string id,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(
            HttpMethod.Patch,
            "api/people/{id}/relationships/ownedTodoItems"
        )
            .SetPathParameter("id", id)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="input">The identities of the todoItems to remove from the ownedTodoItems relationship.</param>
    /// <param name="id">The identifier of the person to remove todoItems from.</param>
    public async Task DeletePersonOwnedTodoItemsRelationshipAsync(
        ToManyTodoItemInRequest input,
        string id,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(
            HttpMethod.Delete,
            "api/people/{id}/relationships/ownedTodoItems"
        )
            .SetPathParameter("id", id)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <summary>Compare the returned ETag HTTP header with an earlier one to determine if the response has changed since it was fetched.</summary>
    /// <param name="id">The identifier of the person whose related todoItem identities to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task HeadPersonOwnedTodoItemsRelationshipAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(
            HttpMethod.Head,
            "api/people/{id}/relationships/ownedTodoItems"
        )
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }
}
