// This file was generated by liblab | https://liblab.com/

using System.Net.Http.Json;
using JsonApiDotNetCoreClientExample.Http;
using JsonApiDotNetCoreClientExample.Http.Serialization;
using JsonApiDotNetCoreClientExample.Models;

namespace JsonApiDotNetCoreClientExample.Services;

public class TagsService : BaseService
{
    internal TagsService(HttpClient httpClient)
        : base(httpClient) { }

    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task<TagCollectionResponseDocument> GetTagCollectionAsync(
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        var request = new RequestBuilder(HttpMethod.Get, "api/tags")
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<TagCollectionResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <param name="input">The attributes and relationships of the tag to create.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    public async Task<TagPrimaryResponseDocument> PostTagAsync(
        TagPostRequestDocument input,
        object? query = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));

        var request = new RequestBuilder(HttpMethod.Post, "api/tags")
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<TagPrimaryResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Compare the returned ETag HTTP header with an earlier one to determine if the response has changed since it was fetched.</summary>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task HeadTagCollectionAsync(
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        var request = new RequestBuilder(HttpMethod.Head, "api/tags")
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="id">The identifier of the tag to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task<TagPrimaryResponseDocument> GetTagAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Get, "api/tags/{id}")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<TagPrimaryResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <param name="input">The attributes and relationships of the tag to update. Omitted fields are left unchanged.</param>
    /// <param name="id">The identifier of the tag to update.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    public async Task<TagPrimaryResponseDocument> PatchTagAsync(
        TagPatchRequestDocument input,
        string id,
        object? query = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Patch, "api/tags/{id}")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<TagPrimaryResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <param name="id">The identifier of the tag to delete.</param>
    public async Task DeleteTagAsync(string id, CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Delete, "api/tags/{id}")
            .SetPathParameter("id", id)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <summary>Compare the returned ETag HTTP header with an earlier one to determine if the response has changed since it was fetched.</summary>
    /// <param name="id">The identifier of the tag to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task HeadTagAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Head, "api/tags/{id}")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="id">The identifier of the tag whose related todoItems to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task<TodoItemCollectionResponseDocument> GetTagTodoItemsAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Get, "api/tags/{id}/todoItems")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<TodoItemCollectionResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <summary>Compare the returned ETag HTTP header with an earlier one to determine if the response has changed since it was fetched.</summary>
    /// <param name="id">The identifier of the tag whose related todoItems to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`include`](https://www.jsonapi.net/usage/reading/including-relationships.html)/[`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task HeadTagTodoItemsAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Head, "api/tags/{id}/todoItems")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="id">The identifier of the tag whose related todoItem identities to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task<TodoItemIdentifierCollectionResponseDocument> GetTagTodoItemsRelationshipAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Get, "api/tags/{id}/relationships/todoItems")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();

        return await response
                .Content.ReadFromJsonAsync<TodoItemIdentifierCollectionResponseDocument>(
                    _jsonSerializerOptions,
                    cancellationToken
                )
                .ConfigureAwait(false) ?? throw new Exception("Failed to deserialize response.");
    }

    /// <param name="input">The identities of the todoItems to add to the todoItems relationship.</param>
    /// <param name="id">The identifier of the tag to add todoItems to.</param>
    public async Task PostTagTodoItemsRelationshipAsync(
        ToManyTodoItemInRequest input,
        string id,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Post, "api/tags/{id}/relationships/todoItems")
            .SetPathParameter("id", id)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="input">The identities of the todoItems to assign to the todoItems relationship, or an empty array to clear the relationship.</param>
    /// <param name="id">The identifier of the tag whose todoItems relationship to assign.</param>
    public async Task PatchTagTodoItemsRelationshipAsync(
        ToManyTodoItemInRequest input,
        string id,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Patch, "api/tags/{id}/relationships/todoItems")
            .SetPathParameter("id", id)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <param name="input">The identities of the todoItems to remove from the todoItems relationship.</param>
    /// <param name="id">The identifier of the tag to remove todoItems from.</param>
    public async Task DeleteTagTodoItemsRelationshipAsync(
        ToManyTodoItemInRequest input,
        string id,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(input, nameof(input));
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Delete, "api/tags/{id}/relationships/todoItems")
            .SetPathParameter("id", id)
            .SetContentAsJson(input, _jsonSerializerOptions)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }

    /// <summary>Compare the returned ETag HTTP header with an earlier one to determine if the response has changed since it was fetched.</summary>
    /// <param name="id">The identifier of the tag whose related todoItem identities to retrieve.</param>
    /// <param name="query">For syntax, see the documentation for the [`filter`](https://www.jsonapi.net/usage/reading/filtering.html)/[`sort`](https://www.jsonapi.net/usage/reading/sorting.html)/[`page`](https://www.jsonapi.net/usage/reading/pagination.html)/[`fields`](https://www.jsonapi.net/usage/reading/sparse-fieldset-selection.html) query string parameters.</param>
    /// <param name="ifNoneMatch">A list of ETags, resulting in HTTP status 304 without a body, if one of them matches the current fingerprint.</param>
    public async Task HeadTagTodoItemsRelationshipAsync(
        string id,
        object? query = null,
        string? ifNoneMatch = null,
        CancellationToken cancellationToken = default
    )
    {
        ArgumentNullException.ThrowIfNull(id, nameof(id));

        var request = new RequestBuilder(HttpMethod.Head, "api/tags/{id}/relationships/todoItems")
            .SetPathParameter("id", id)
            // Commented out to workaround bug: It sends ?query= instead of key-value pairs, resulting in HTTP 400.
            //.SetQueryParameter("query", query)
            .SetOptionalHeader("If-None-Match", ifNoneMatch)
            .Build();

        var response = await _httpClient
            .SendAsync(request, cancellationToken)
            .ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
    }
}
