# This workflow will build a .NET project
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-net

# TODO: Restore notification for failed actions
# TODO: Review https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions
# TODO: Review https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions
# TODO: Adapt name and .yml file name (resets package counter)
name: .NET

# Advantages
# - Max parallel builds (jobs) is 20 (MacOS 5)
# - Job timeout is 6 hours, workflow 35 days
# - Artifact retention is 90 days
# - Linux runs faster
# - Integrated in GitHub
# - Rich ecosystem of actions
# - Timings per operation (build, test, cleanup)
# - Test summaries
# - Improved security
# - Easier to try .NET preview versions

on:
  push:
    branches: [ 'master', 'release/**' ]
  pull_request:
    branches: [ 'master', 'release/**' ]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  # Windows comes with PostgreSQL pre-installed, and defines the PGPASSWORD environment variable. Remove it as it interferes
  # with the tests running from AppVeyor
  PGPASSWORD: ""

jobs:
  build-and-test:
    # TODO: Update required checks in GitHub settings
    # TODO: Update status badges in README.md
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
    - name: Setup PostgreSQL
      uses: ikalnytskyi/action-setup-postgres@v4
      with:
        username: postgres
        password: postgres
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 6.0.x
    - name: Setup PowerShell (Ubuntu)
      if: matrix.os == 'ubuntu-latest'
      run: |
        # Update the list of packages
        sudo apt-get update
        # Install pre-requisite packages.
        sudo apt-get install -y wget apt-transport-https software-properties-common
        # Download the Microsoft repository GPG keys
        wget -q "https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb"
        # Register the Microsoft repository GPG keys
        sudo dpkg -i packages-microsoft-prod.deb
        # Delete the the Microsoft repository GPG keys file
        rm packages-microsoft-prod.deb
        # Update the list of packages after we added packages.microsoft.com
        sudo apt-get update
        # Install PowerShell
        sudo apt-get install -y powershell
    - name: Setup PowerShell (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        Invoke-WebRequest -Uri "https://github.com/PowerShell/PowerShell/releases/download/v7.3.6/PowerShell-7.3.6-win-x64.zip" -OutFile "$env:RUNNER_TEMP\\PowerShell-7.3.6-win-x64.zip"
        Expand-Archive -LiteralPath "$env:RUNNER_TEMP\\PowerShell-7.3.6-win-x64.zip" -DestinationPath "C:\Program Files\PowerShell\7"
    - name: Setup PowerShell (macOS)
      if: matrix.os == 'macos-latest'
      run: |
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
        brew install --cask powershell
    #- name: Setup PowerShell
    #  shell: pwsh
    #  run: |
    #    dotnet tool install --global PowerShell
    #    #Write-Host "${HOME}/.dotnet/tools" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
    - name: Show installed versions
      shell: pwsh
      run: |
        Write-Host "$(pwsh --version) is installed at $PSHOME"
        psql --version
        Write-Host "Using .NET SDK: $(dotnet --version)"
        #Write-Host "Installed .NET SDKs:"
        #dotnet --list-sdks --list-runtimes
        #Write-Host "Installed .NET runtimes:"
        #dotnet --list-runtimes
        #Write-Host "Environment variables:"
        #dir env: | %{"{0}={1}" -f $_.Name,$_.Value}
    - name: Git checkout
      uses: actions/checkout@v3
    - name: Restore tools
      run: dotnet tool restore
    - name: Restore packages
      run: dotnet restore
    - name: Calculate version suffix
      shell: pwsh
      run: |
        if ($env:GITHUB_REF_TYPE -eq 'tag') {
            # Get the version suffix from the repo tag. Example: v1.0.0-preview1-final => preview1-final
            $segments = $env:GITHUB_REF_NAME -split "-"
            $suffixSegments = $segments[1..-1]
            $versionSuffix = $suffixSegments -join "-"
        }
        else {
            # Get the version suffix from the auto-incrementing build number. Example: 123 => master-0123
            $revision = "{0:D4}" -f [convert]::ToInt32($env:GITHUB_RUN_NUMBER, 10)
            $versionSuffix = "$($env:GITHUB_HEAD_REF ?? $env:GITHUB_REF_NAME)-$revision"
        }
        Write-Output "Using version suffix: $versionSuffix"
        Write-Output "PACKAGE_VERSION_SUFFIX=$versionSuffix" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
    - name: Build
      shell: pwsh
      run: dotnet build --no-restore --configuration Release --version-suffix=$env:PACKAGE_VERSION_SUFFIX
    - name: Test
      run: dotnet test --no-build --configuration Release --collect:"XPlat Code Coverage" --logger "GitHubActions"
    - name: Upload coverage to codecov.io
      if: matrix.os == 'ubuntu-latest'
      uses: codecov/codecov-action@v3
    - name: Create packages
      shell: pwsh
      run: dotnet pack --no-build --configuration Release --output $env:GITHUB_WORKSPACE/artifacts/packages --version-suffix=$env:PACKAGE_VERSION_SUFFIX
    - name: Upload packages to artifacts
      #if: matrix.os == 'ubuntu-latest'
      uses: actions/upload-artifact@v3
      with:
        name: packages-${{ matrix.os }}
        path: artifacts/packages
# TODO: Upload pre-release NuGet package - https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-nuget-registry
# TODO: Push to NuGet on new release
# TODO: Try CodeQL Analysis
# TODO: Add dependabot.yml (GH Security: Enable Dependabot version updates)
    - name: Generate documentation
      shell: pwsh
      env:
        DOCFX_SOURCE_BRANCH_NAME: ${{ github.base_ref || github.ref_name }}
      run: |
        Write-Host "Using branch name: $env:DOCFX_SOURCE_BRANCH_NAME"
        cd docs
        & ./generate-examples.ps1
        dotnet docfx docfx.json
    - name: Build website
      shell: pwsh
      run: |
        cd docs
        Copy-Item CNAME _site/CNAME
        Copy-Item home/*.html _site/
        Copy-Item home/*.ico _site/
        New-Item -Force _site/styles -ItemType Directory | Out-Null
        Copy-Item -Recurse home/assets/* _site/styles/
    - name: Upload documentation to artifacts
      #if: matrix.os == 'windows-latest'
      uses: actions/upload-artifact@v3
      with:
        name: documentation-${{ matrix.os }}
        path: docs/_site
    - name: Publish website
      # TODO: Setup Deployment protection rules (https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site)
      if: (github.event_name == 'push' && github.ref == 'refs/heads/main')
      shell: pwsh
      run: |
        # TODO: publish to gh_pages
        Write-Host "TODO: Publish documentation"

  inspect-code:
    timeout-minutes: 30
    runs-on: ubuntu-latest
    steps:
    - name: Git checkout
      uses: actions/checkout@v3
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 6.0.x
    - name: Restore tools
      run: dotnet tool restore
    - name: InspectCode
      shell: pwsh
      run: |
        $inspectCodeOutputPath = Join-Path $env:RUNNER_TEMP 'jetbrains-inspectcode-results.xml'
        Write-Output "INSPECT_CODE_OUTPUT_PATH=$inspectCodeOutputPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        dotnet jb inspectcode JsonApiDotNetCore.sln --build --output="$inspectCodeOutputPath" --profile=WarningSeverities.DotSettings --properties:Configuration=Release --severity=WARNING --verbosity=WARN -dsl=GlobalAll -dsl=GlobalPerProduct -dsl=SolutionPersonal -dsl=ProjectPersonal
    - name: Verify outcome
      shell: pwsh
      run: |
        [xml]$xml = Get-Content $env:INSPECT_CODE_OUTPUT_PATH
        if ($xml.report.Issues -and $xml.report.Issues.Project) {
            foreach ($project in $xml.report.Issues.Project) {
                if ($project.Issue.Count -gt 0) {
                    $project.ForEach({
                        Write-Output "`nProject $($project.Name)"
                        $failed = $true

                        $_.Issue.ForEach({
                            $issueType = $xml.report.IssueTypes.SelectSingleNode("IssueType[@Id='$($_.TypeId)']")
                            $severity = $_.Severity ?? $issueType.Severity

                            Write-Output "[$severity] $($_.File):$($_.Line) $($_.TypeId): $($_.Message)"
                        })
                    })
                }
            }

            if ($failed) {
                Write-Error "One or more projects failed code inspection."
            }
            else {
                Write-Output "No issues found."
            }
        }
  cleanup-code:
    timeout-minutes: 30
    # TODO: Test with PR from community user (pull_request_target)
    #if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
    - name: Git checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 2
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 6.0.x
    - name: Restore tools
      run: dotnet tool restore
    - name: Restore packages
      run: dotnet restore
    - name: CleanupCode (on PR diff)
      shell: pwsh
      run: |
        # Not using the environment variables for SHAs, because they may be outdated. This happens on force-push after the build is queued, but before it starts.
        # The below works because HEAD is at the merge commit, so HEAD~1 is at the base branch.
        $headCommitHash = git rev-parse HEAD
        $baseCommitHash = git rev-parse HEAD~1

        # TODO: What happens when PR is empty?
        if ($baseCommitHash -ne $headCommitHash) {
            Write-Output "Running code cleanup on commit range $baseCommitHash..$headCommitHash in pull request."
            dotnet regitlint -s JsonApiDotNetCore.sln --print-command --skip-tool-check --max-runs=5 --jb-profile="JADNC Full Cleanup" --jb --properties:Configuration=Release --jb --verbosity=WARN -f commits -a $headCommitHash -b $baseCommitHash --fail-on-diff --print-diff
        }
        else {
            Write-Output "No changed files in pull request."
        }
